using LinearAlgebra: √ó, norm, norm_sqr, dot

using ClimaCore: Operators, Fields

include("schur_complement_W.jl")
include("hyperdiffusion.jl")

# Constants required before `include("staggered_nonhydrostatic_model.jl")`
# const FT = ?    # floating-point type
# const p_0 = ?   # reference pressure
# const R_d = ?   # dry specific gas constant
# const Œ∫ = ?     # kappa
# const T_tri = ? # triple point temperature
# const grav = ?  # gravitational acceleration
# const Œ© = ?     # planet's rotation rate (only required if space is spherical)
# const f = ?     # Coriolis frequency (only required if space is flat)

# To add additional terms to the explicit part of the tendency, define new
# methods for `additional_cache` and `additional_tendency!`.

const cp_d = R_d / Œ∫     # heat capacity at constant pressure
const cv_d = cp_d - R_d  # heat capacity at constant volume
const Œ≥ = cp_d / cv_d    # heat capacity ratio

const div‚Çï = Operators.Divergence()
const wdiv‚Çï = Operators.WeakDivergence()
const grad‚Çï = Operators.Gradient()
const wgrad‚Çï = Operators.WeakGradient()
const curl‚Çï = Operators.Curl()
const wcurl‚Çï = Operators.WeakCurl()

const ·∂úinterp = Operators.InterpolateF2C()
const ·∂†interp = Operators.InterpolateC2F(
    bottom = Operators.Extrapolate(),
    top = Operators.Extrapolate(),
)
const ·∂údiv·µ• = Operators.DivergenceF2C(
    top = Operators.SetValue(Geometry.Contravariant3Vector(FT(0))),
    bottom = Operators.SetValue(Geometry.Contravariant3Vector(FT(0))),
)
const ·∂†grad·µ• = Operators.GradientC2F(
    bottom = Operators.SetGradient(Geometry.Covariant3Vector(FT(0))),
    top = Operators.SetGradient(Geometry.Covariant3Vector(FT(0))),
)
const ·∂†curl·µ• = Operators.CurlC2F(
    bottom = Operators.SetCurl(Geometry.Contravariant12Vector(FT(0), FT(0))),
    top = Operators.SetCurl(Geometry.Contravariant12Vector(FT(0), FT(0))),
)
const ·∂úFC = Operators.FluxCorrectionC2C(
    bottom = Operators.Extrapolate(),
    top = Operators.Extrapolate(),
)
const ·∂†upwind_product1 = Operators.UpwindBiasedProductC2F()
const ·∂†upwind_product3 = Operators.Upwind3rdOrderBiasedProductC2F(
    bottom = Operators.ThirdOrderOneSided(),
    top = Operators.ThirdOrderOneSided(),
)

const ·∂úinterp_stencil = Operators.Operator2Stencil(·∂úinterp)
const ·∂†interp_stencil = Operators.Operator2Stencil(·∂†interp)
const ·∂údiv·µ•_stencil = Operators.Operator2Stencil(·∂údiv·µ•)
const ·∂†grad·µ•_stencil = Operators.Operator2Stencil(·∂†grad·µ•)

const C123 = Geometry.Covariant123Vector

pressure_œÅŒ∏(œÅŒ∏) = p_0 * (œÅŒ∏ * R_d / p_0)^Œ≥
pressure_œÅe(œÅe, K, Œ¶, œÅ) = œÅ * R_d * ((œÅe / œÅ - K - Œ¶) / cv_d + T_tri)
pressure_œÅe_int(œÅe_int, œÅ) = R_d * (œÅe_int / cv_d + œÅ * T_tri)

get_cache(·∂úlocal_geometry, ·∂†local_geometry, Y, dt, upwinding_mode) = merge(
    default_cache(·∂úlocal_geometry, ·∂†local_geometry, Y, upwinding_mode),
    additional_cache(·∂úlocal_geometry, ·∂†local_geometry, dt),
)

function default_cache(·∂úlocal_geometry, ·∂†local_geometry, Y, upwinding_mode)
    ·∂úcoord = ·∂úlocal_geometry.coordinates
    if eltype(·∂úcoord) <: Geometry.LatLongZPoint
        ·∂úf = @. 2 * Œ© * sind(·∂úcoord.lat)
    else
        ·∂úf = map(_ -> f, ·∂úlocal_geometry)
    end
    ·∂úf = @. Geometry.Contravariant3Vector(Geometry.WVector(·∂úf))
    return (;
        ·∂úuvw = similar(·∂úlocal_geometry, Geometry.Covariant123Vector{FT}),
        ·∂úK = similar(·∂úlocal_geometry, FT),
        ·∂úŒ¶ = grav .* ·∂úcoord.z,
        ·∂úp = similar(·∂úlocal_geometry, FT),
        ·∂úœâ¬≥ = similar(·∂úlocal_geometry, Geometry.Contravariant3Vector{FT}),
        ·∂†œâ¬π¬≤ = similar(·∂†local_geometry, Geometry.Contravariant12Vector{FT}),
        ·∂†u¬π¬≤ = similar(·∂†local_geometry, Geometry.Contravariant12Vector{FT}),
        ·∂†u¬≥ = similar(·∂†local_geometry, Geometry.Contravariant3Vector{FT}),
        ·∂úf,
        ‚àÇ·∂úK‚àÇ·∂†w_data = similar(
            ·∂úlocal_geometry,
            Operators.StencilCoefs{-half, half, NTuple{2, FT}},
        ),
        ·∂†upwind_product = upwinding_mode == :first_order ? ·∂†upwind_product1 :
                          upwinding_mode == :third_order ? ·∂†upwind_product3 :
                          nothing,
        ghost_buffer = (
            c = Spaces.create_dss_buffer(Y.c),
            f = Spaces.create_dss_buffer(Y.f),
            œá = Spaces.create_dss_buffer(Y.c.œÅ), # for hyperdiffusion
            œáw = Spaces.create_dss_buffer(Y.f.w.components.data.:1), # for hyperdiffusion
            œáu‚Çï = Spaces.create_dss_buffer(Y.c.u‚Çï), # for hyperdiffusion
        ),
    )
end

additional_cache(·∂úlocal_geometry, ·∂†local_geometry, dt) = (;)

function implicit_tendency!(Y‚Çú, Y, p, t)
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úK, ·∂úŒ¶, ·∂úp, ·∂†upwind_product) = p

    # Used for automatically computing the Jacobian ‚àÇY‚Çú/‚àÇY. Currently requires
    # allocation because the cache is stored separately from Y, which means that
    # similar(Y, <:Dual) doesn't allocate an appropriate cache for computing Y‚Çú.
    if eltype(Y) <: Dual
        ·∂úK = similar(·∂úœÅ)
        ·∂úp = similar(·∂úœÅ)
    end

    @. ·∂úK = norm_sqr(C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))) / 2

    @. Y‚Çú.c.œÅ = -(·∂údiv·µ•(·∂†interp(·∂úœÅ) * ·∂†w))

    if :œÅŒ∏ in propertynames(Y.c)
        ·∂úœÅŒ∏ = Y.c.œÅŒ∏
        @. ·∂úp = pressure_œÅŒ∏(·∂úœÅŒ∏)
        if isnothing(·∂†upwind_product)
            @. Y‚Çú.c.œÅŒ∏ = -(·∂údiv·µ•(·∂†interp(·∂úœÅŒ∏) * ·∂†w))
        else
            @. Y‚Çú.c.œÅŒ∏ =
                -(·∂údiv·µ•(·∂†interp(Y.c.œÅ) * ·∂†upwind_product(·∂†w, ·∂úœÅŒ∏ / Y.c.œÅ)))
        end
    elseif :œÅe in propertynames(Y.c)
        ·∂úœÅe = Y.c.œÅe
        @. ·∂úp = pressure_œÅe(·∂úœÅe, ·∂úK, ·∂úŒ¶, ·∂úœÅ)
        if isnothing(·∂†upwind_product)
            @. Y‚Çú.c.œÅe = -(·∂údiv·µ•(·∂†interp(·∂úœÅe + ·∂úp) * ·∂†w))
        else
            @. Y‚Çú.c.œÅe = -(·∂údiv·µ•(
                ·∂†interp(Y.c.œÅ) * ·∂†upwind_product(·∂†w, (·∂úœÅe + ·∂úp) / Y.c.œÅ),
            ))
        end
    elseif :œÅe_int in propertynames(Y.c)
        ·∂úœÅe_int = Y.c.œÅe_int
        @. ·∂úp = pressure_œÅe_int(·∂úœÅe_int, ·∂úœÅ)
        if isnothing(·∂†upwind_product)
            @. Y‚Çú.c.œÅe_int = -(
                ·∂údiv·µ•(·∂†interp(·∂úœÅe_int + ·∂úp) * ·∂†w) -
                ·∂úinterp(dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(·∂†w)))
            )
            # or, equivalently,
            # Y‚Çú.c.œÅe_int = -(·∂údiv·µ•(·∂†interp(·∂úœÅe_int) * ·∂†w) + ·∂úp * ·∂údiv·µ•(·∂†w))
        else
            @. Y‚Çú.c.œÅe_int = -(
                ·∂údiv·µ•(
                    ·∂†interp(Y.c.œÅ) *
                    ·∂†upwind_product(·∂†w, (·∂úœÅe_int + ·∂úp) / Y.c.œÅ),
                ) -
                ·∂úinterp(dot(·∂†grad·µ•(·∂úp), Geometry.Contravariant3Vector(·∂†w)))
            )
        end
    end

    Y‚Çú.c.u‚Çï .= Ref(zero(eltype(Y‚Çú.c.u‚Çï)))

    @. Y‚Çú.f.w = -(·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ) + ·∂†grad·µ•(·∂úK + ·∂úŒ¶))

    # TODO: Add flux correction to the Jacobian
    # @. Y‚Çú.c.œÅ += ·∂úFC(·∂†w, ·∂úœÅ)
    # if :œÅŒ∏ in propertynames(Y.c)
    #     @. Y‚Çú.c.œÅŒ∏ += ·∂úFC(·∂†w, ·∂úœÅŒ∏)
    # elseif :œÅe in propertynames(Y.c)
    #     @. Y‚Çú.c.œÅe += ·∂úFC(·∂†w, ·∂úœÅe)
    # elseif :œÅe_int in propertynames(Y.c)
    #     @. Y‚Çú.c.œÅe_int += ·∂úFC(·∂†w, ·∂úœÅe_int)
    # end

    return Y‚Çú
end

function remaining_tendency!(Y‚Çú, Y, p, t)
    Y‚Çú .= zero(eltype(Y‚Çú))
    default_remaining_tendency!(Y‚Çú, Y, p, t)
    additional_tendency!(Y‚Çú, Y, p, t)
    Spaces.weighted_dss_start!(Y‚Çú.c, p.ghost_buffer.c)
    Spaces.weighted_dss_start!(Y‚Çú.f, p.ghost_buffer.f)
    Spaces.weighted_dss_internal!(Y‚Çú.c, p.ghost_buffer.c)
    Spaces.weighted_dss_internal!(Y‚Çú.f, p.ghost_buffer.f)
    Spaces.weighted_dss_ghost!(Y‚Çú.c, p.ghost_buffer.c)
    Spaces.weighted_dss_ghost!(Y‚Çú.f, p.ghost_buffer.f)
    return Y‚Çú
end

function default_remaining_tendency!(Y‚Çú, Y, p, t)
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úuvw, ·∂úK, ·∂úŒ¶, ·∂úp, ·∂úœâ¬≥, ·∂†œâ¬π¬≤, ·∂†u¬π¬≤, ·∂†u¬≥, ·∂úf) = p
    point_type = eltype(Fields.local_geometry_field(axes(Y.c)).coordinates)

    @. ·∂úuvw = C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))
    @. ·∂úK = norm_sqr(·∂úuvw) / 2

    # Mass conservation

    @. Y‚Çú.c.œÅ -= div‚Çï(·∂úœÅ * ·∂úuvw)
    @. Y‚Çú.c.œÅ -= ·∂údiv·µ•(·∂†interp(·∂úœÅ * ·∂úu‚Çï))

    # Energy conservation

    ·∂úœÅe = Y.c.œÅe
    @. ·∂úp = pressure_œÅe(·∂úœÅe, ·∂úK, ·∂úŒ¶, ·∂úœÅ)
    @. Y‚Çú.c.œÅe -= div‚Çï((·∂úœÅe + ·∂úp) * ·∂úuvw)
    @. Y‚Çú.c.œÅe -= ·∂údiv·µ•(·∂†interp((·∂úœÅe + ·∂úp) * ·∂úu‚Çï))

    # Momentum conservation

    if point_type <: Geometry.Abstract3DPoint
        @. ·∂úœâ¬≥ = curl‚Çï(·∂úu‚Çï)
        @. ·∂†œâ¬π¬≤ = curl‚Çï(·∂†w)
    elseif point_type <: Geometry.Abstract2DPoint
        ·∂úœâ¬≥ .= Ref(zero(eltype(·∂úœâ¬≥)))
        @. ·∂†œâ¬π¬≤ = Geometry.Contravariant12Vector(curl‚Çï(·∂†w))
    end
    @. ·∂†œâ¬π¬≤ += ·∂†curl·µ•(·∂úu‚Çï)

    # TODO: Modify to account for topography
    @. ·∂†u¬π¬≤ = Geometry.Contravariant12Vector(·∂†interp(·∂úu‚Çï))
    @. ·∂†u¬≥ = Geometry.Contravariant3Vector(·∂†w)

    @. Y‚Çú.c.u‚Çï -=
        ·∂úinterp(·∂†œâ¬π¬≤ √ó ·∂†u¬≥) + (·∂úf + ·∂úœâ¬≥) √ó Geometry.Contravariant12Vector(·∂úu‚Çï)
    if point_type <: Geometry.Abstract3DPoint
        @. Y‚Çú.c.u‚Çï -= grad‚Çï(·∂úp) / ·∂úœÅ + grad‚Çï(·∂úK + ·∂úŒ¶)
    elseif point_type <: Geometry.Abstract2DPoint
        @. Y‚Çú.c.u‚Çï -=
            Geometry.Covariant12Vector(grad‚Çï(·∂úp) / ·∂úœÅ + grad‚Çï(·∂úK + ·∂úŒ¶))
    end

    @. Y‚Çú.f.w -= ·∂†œâ¬π¬≤ √ó ·∂†u¬π¬≤
end

additional_tendency!(Y‚Çú, Y, p, t) = nothing

function Wfact!(W, Y, p, dtŒ≥, t)
    (; flags, dtŒ≥_ref, ‚àÇ·∂úœÅ‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ, ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ) = W
    ·∂úœÅ = Y.c.œÅ
    ·∂úu‚Çï = Y.c.u‚Çï
    ·∂†w = Y.f.w
    (; ·∂úK, ·∂úŒ¶, ·∂úp, ‚àÇ·∂úK‚àÇ·∂†w_data, ·∂†upwind_product) = p

    dtŒ≥_ref[] = dtŒ≥

    ·∂†w_data = ·∂†w.components.data.:1

    Œµw = Ref(Geometry.Covariant3Vector(eps(FT)))
    to_scalar(vector) = vector.u‚ÇÉ

    @. ‚àÇ·∂úK‚àÇ·∂†w_data =
        ·∂úinterp(·∂†w_data) *
        norm_sqr(one(·∂úinterp(·∂†w))) *
        ·∂úinterp_stencil(one(·∂†w_data))

    @. ‚àÇ·∂úœÅ‚Çú‚àÇ·∂†ùïÑ = -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅ) * one(·∂†w)))


    ·∂úœÅe = Y.c.œÅe
    @. ·∂úK = norm_sqr(C123(·∂úu‚Çï) + C123(·∂úinterp(·∂†w))) / 2
    @. ·∂úp = pressure_œÅe(·∂úœÅe, ·∂úK, ·∂úŒ¶, ·∂úœÅ)

    if isnothing(·∂†upwind_product)
        @. ‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ =
            -(·∂údiv·µ•_stencil(·∂†interp(·∂úœÅe + ·∂úp) * one(·∂†w))) - compose(
                ·∂údiv·µ•_stencil(·∂†w),
                compose(
                    ·∂†interp_stencil(one(·∂úp)),
                    -(·∂úœÅ * R_d / cv_d) * ‚àÇ·∂úK‚àÇ·∂†w_data,
                ),
            )
    else
        error("‚àÇ·∂úùîº‚Çú‚àÇ·∂†ùïÑ_mode must be :no_‚àÇ·∂úp‚àÇ·∂úK when using œÅe with \
                upwinding")
    end

    to_scalar_coefs(vector_coefs) =
        map(vector_coef -> vector_coef.u‚ÇÉ, vector_coefs)

    @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úùîº = to_scalar_coefs(
        -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(R_d / cv_d * one(·∂úœÅe)),
    )

    # flags.‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ_mode == :exact
    @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂úœÅ = to_scalar_coefs(
        -1 / ·∂†interp(·∂úœÅ) *
        ·∂†grad·µ•_stencil(R_d * (-(·∂úK + ·∂úŒ¶) / cv_d + T_tri)) +
        ·∂†grad·µ•(·∂úp) / ·∂†interp(·∂úœÅ)^2 * ·∂†interp_stencil(one(·∂úœÅ)),
    )

    @. ‚àÇ·∂†ùïÑ‚Çú‚àÇ·∂†ùïÑ = to_scalar_coefs(
        compose(
            -1 / ·∂†interp(·∂úœÅ) * ·∂†grad·µ•_stencil(-(·∂úœÅ * R_d / cv_d)) +
            -1 * ·∂†grad·µ•_stencil(one(·∂úK)),
            ‚àÇ·∂úK‚àÇ·∂†w_data,
        ),
    )

end
